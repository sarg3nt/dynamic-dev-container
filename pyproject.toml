# cspell:ignore pytest mypy pkgs datetimez Pyflakes Pylint isort pycodestyle pydocstyle pyupgrade pyproject pydantic dotenv sdist artifactory nexus jfrog sonatype testpypi

####### Example pyproject.toml file for Python projects #######
# This is a template configuration file for Python projects using modern tools.
# Replace placeholder values with your actual project information.

# Build system configuration - tells Python how to build your package
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

# Package index configuration for pip installations
[tool.pip]
index-url = "https://pypi.org/simple/"  # Replace with your package index URL if using private repositories

# Core project metadata - this is the main configuration for your Python package
[project]
name = "my-awesome-project"                           # Your package name (no spaces, lowercase recommended)
dynamic = ["version"]                                 # Version will be read from __about__.py
description = "A brief description of your project"   # One-line summary of what your project does
readme = "README.md"                                  # Path to your README file
requires-python = ">=3.12"                            # Minimum Python version required
license = {text = "MIT"}                              # Your project's license (MIT, Apache-2.0, GPL-3.0, etc.)
keywords = ["python", "cli", "automation"]            # Keywords to help users find your project
authors = [
  { name = "Your Name", email = "your.email@example.com" }
]
# PyPI classifiers help categorize your project
classifiers = [
  "Development Status :: 4 - Beta",
  "Programming Language :: Python",
  "Programming Language :: Python :: 3.12",
  "Programming Language :: Python :: 3.13",
]

# Runtime dependencies - packages your project needs to run
dependencies = [
  # Replace these example dependencies with your actual requirements
  "click>=8.0,<9.0",      # CLI framework for command-line tools
  "requests>=2.28,<3.0",  # HTTP library for web requests
  "pydantic>=2.0,<3.0",   # Data validation and parsing
]

# Optional dependencies for development and testing
[project.optional-dependencies]
# Development tools (install with: pip install -e .[dev])
dev = [
  "hatch>=1.14,<2.0",           # Build and project management tool
  "pytest>=8.3,<9.0",          # Testing framework
  "pytest-mock>=3.14,<4.0",    # Mock objects for pytest
  "pytest-cov>=6.0,<7.0",      # Coverage reporting for tests
  "ruff>=0.9,<1.0",             # Fast Python linter and formatter
  "mypy>=1.17,<2.0",            # Static type checker
  "watchdog>=6.0,<7.0",        # File system event monitoring
  "python-dotenv>=1.1,<2.0",   # Environment variable management
]

# Project URLs - links displayed on PyPI and in documentation
[project.urls]
Documentation = "https://github.com/yourusername/my-awesome-project/blob/main/README.md"
Homepage = "https://github.com/yourusername/my-awesome-project"
Source = "https://github.com/yourusername/my-awesome-project"
"Bug Tracker" = "https://github.com/yourusername/my-awesome-project/issues"

# Version configuration - tells Hatch where to find the version string
[tool.hatch.version]
path = "src/my_awesome_project/__about__.py"  # Replace 'my_awesome_project' with your package name

# Build configuration - specifies which files to include in the package
[tool.hatch.build.targets.wheel]
packages = ["src/my_awesome_project"]  # Replace 'my_awesome_project' with your package name

[tool.hatch.build.targets.sdist]
exclude = [
  "/.github",
  "/docs",
  "/.vscode",
  "/.devcontainer",
]

# Hatch publish configuration for package repositories
# This section configures where your Python packages will be published.
# By default, it's set up for PyPI (the main Python package index).
# 
# To publish to PyPI:
# 1. Create an account at https://pypi.org/
# 2. Generate an API token at https://pypi.org/manage/account/
# 3. Set environment variables:
#    export HATCH_INDEX_USER=__token__
#    export HATCH_INDEX_AUTH=your_pypi_api_token
# 4. Run: hatch publish
#
# For TestPyPI (recommended for testing):
# 1. Create an account at https://test.pypi.org/
# 2. Generate an API token at https://test.pypi.org/manage/account/
# 3. Run: hatch publish -r test

[tool.hatch.publish.index]
disable = false  # Set to true to disable publishing entirely

# Default repository (PyPI)
# Remove the # to enable a specific repository configuration
# [tool.hatch.publish.index.repos.main]
# url = "https://upload.pypi.org/legacy/"  # PyPI upload URL

# Test PyPI repository (recommended for testing before publishing to main PyPI)
# [tool.hatch.publish.index.repos.test]
# url = "https://test.pypi.org/legacy/"

# Example: JFrog Artifactory configuration
# Replace with your actual Artifactory URL and repository names
# [tool.hatch.publish.index.repos.artifactory-dev]
# url = "https://your-company.jfrog.io/artifactory/api/pypi/your-repo-dev/simple/"
# 
# [tool.hatch.publish.index.repos.artifactory-prod]
# url = "https://your-company.jfrog.io/artifactory/api/pypi/your-repo-prod/simple/"

# Example: Sonatype Nexus configuration
# Replace with your actual Nexus URL and repository names
# [tool.hatch.publish.index.repos.nexus-dev]
# url = "https://your-nexus-server.com/repository/your-repo-dev/simple/"
# 
# [tool.hatch.publish.index.repos.nexus-prod]
# url = "https://your-nexus-server.com/repository/your-repo-prod/simple/"

# Example: Azure DevOps Artifacts configuration
# [tool.hatch.publish.index.repos.azure-artifacts]
# url = "https://pkgs.dev.azure.com/your-org/_packaging/your-feed/pypi/upload/"

# Example: GitHub Packages configuration
# [tool.hatch.publish.index.repos.github]
# url = "https://upload.pypi.org/legacy/"  # GitHub uses PyPI protocol
# username = "your-github-username"

# Authentication methods:
# 1. Environment variables (recommended):
#    export HATCH_INDEX_USER=your_username
#    export HATCH_INDEX_AUTH=your_password_or_token
# 
# 2. For repository-specific auth:
#    export HATCH_INDEX_REPOS_YOUR_REPO_USER=your_username
#    export HATCH_INDEX_REPOS_YOUR_REPO_AUTH=your_password_or_token
#
# 3. Interactive prompt (Hatch will ask for credentials when needed)

# To publish to a specific repository:
# hatch publish -r repository-name
# Example: hatch publish -r test

# Development environment configuration for Hatch
[tool.hatch.envs.default]
dependencies = [
  "pytest>=8.3,<9.0",
  "pytest-mock>=3.14,<4.0",
  "pytest-cov>=6.0,<7.0",
  "ruff>=0.9,<1.0",
  "mypy>=1.17,<2.0",
]

[tool.hatch.envs.default.scripts]
test = "pytest {args:tests}"
test-cov = "pytest --cov=my_awesome_project --cov-report=term-missing --cov-report=html {args:tests}"
lint = "ruff check {args:src tests}"
format = "ruff format {args:src tests}"
type-check = "mypy {args:src tests}"
all = ["lint", "format", "type-check", "test-cov"]

[tool.hatch.envs.types]
extra-dependencies = ["mypy>=1.17,<2.0"]

[tool.hatch.envs.types.scripts]
check = "mypy --install-types --non-interactive {args:src tests}"

# Test coverage configuration
[tool.coverage.run]
source_pkgs = ["my_awesome_project", "tests"]  # Replace 'my_awesome_project' with your package name
branch = true          # Enable branch coverage
parallel = true        # Allow parallel test execution
omit = [
  "src/my_awesome_project/__about__.py",  # Skip version file from coverage
]

[tool.coverage.paths]
# Map different path patterns to the same source for coverage combining
project = ["src", "*/my_awesome_project/src"]      # Replace 'my_awesome_project' with your package name
tests = ["tests", "*/my_awesome_project/tests"]    # Replace 'my_awesome_project' with your package name

[tool.coverage.report]
# Lines to exclude from coverage reporting
exclude_lines = [
  "no cov",                           # Pragma comments
  "if __name__ == .__main__.:",       # Main execution blocks
  "if TYPE_CHECKING:",                # Type checking imports
]

# Pytest configuration
[tool.pytest.ini_options]
minversion = "8.0"
addopts = [
  "--strict-markers",
  "--strict-config",
  "--doctest-modules",
  "--import-mode=importlib",
]
# Test discovery
testpaths = ["tests"]
# Custom markers for test organization
markers = [
  "order(number): runs tests in the order given",
  "serial: marks tests as serial (not parallel)",
  "slow: marks tests as slow (deselect with '-m \"not slow\"')",
  "integration: marks tests as integration tests",
  "unit: marks tests as unit tests",
]
# Filter warnings
filterwarnings = [
  "error",
  "ignore::UserWarning",
  "ignore::DeprecationWarning",
]

# Ruff configuration - Python linter and formatter
[tool.ruff]
line-length = 120           # Maximum line length
target-version = "py312"    # Target Python version for rules
src = ["src"]               # Source directories for import detection

[tool.ruff.lint]
# Rule selection - see https://docs.astral.sh/ruff/rules/ for details
select = [
  "F",     # Pyflakes - basic error detection
  "E",     # pycodestyle errors - PEP 8 style violations
  "W",     # pycodestyle warnings - PEP 8 style warnings
  "I",     # isort - import sorting
  "N",     # pep8-naming - naming conventions
  "D",     # pydocstyle - docstring conventions
  "UP",    # pyupgrade - modern Python syntax
  "YTT",   # flake8-2020 - avoid outdated Python patterns
  "ANN",   # flake8-annotations - type annotations
  "ASYNC", # flake8-async - async/await best practices
  "S",     # flake8-bandit - security issues
  "B",     # flake8-bugbear - likely bugs and design problems
  "A",     # flake8-builtins - builtin shadowing
  "COM",   # flake8-commas - trailing commas
  "C4",    # flake8-comprehensions - list/dict comprehensions
  "DTZ",   # flake8-datetimez - datetime usage
  "T10",   # flake8-debugger - debugger statements
  "EM",    # flake8-errmsg - error message formatting
  "EXE",   # flake8-executable - executable file issues
  "ISC",   # flake8-implicit-str-concat - string concatenation
  "ICN",   # flake8-import-conventions - import naming
  "LOG",   # flake8-logging - logging best practices
  "G",     # flake8-logging-format - logging format strings
  "INP",   # flake8-no-pep420 - explicit __init__.py files
  "PIE",   # flake8-pie - misc. lints
  "T20",   # flake8-print - print statements
  "PYI",   # flake8-pyi - type stub files
  "PT",    # flake8-pytest-style - pytest best practices
  "Q",     # flake8-quotes - quote consistency
  "RSE",   # flake8-raise - exception raising
  "RET",   # flake8-return - return statement issues
  "SLF",   # flake8-self - private member access
  "SLOT",  # flake8-slots - __slots__ usage
  "SIM",   # flake8-simplify - code simplification
  "TID",   # flake8-tidy-imports - import organization
  "TC",    # flake8-type-checking - type checking imports
  "INT",   # flake8-gettext - internationalization
  "ARG",   # flake8-unused-arguments - unused function arguments
  "TD",    # flake8-todos - TODO comments
  "ERA",   # eradicate - commented out code
  "PL",    # Pylint - comprehensive Python linting
]

# Rules to ignore - customize based on your project needs
ignore = [
  "E501",    # line-too-long (handled by formatter)
  "D202",    # no-blank-line-after-function (stylistic preference)
  "D203",    # one-blank-line-before-class (conflicts with D211)
  "D213",    # multi-line-summary-second-line (conflicts with D212)
  "T201",    # print statements (useful for CLI tools)
  "D401",    # non-imperative-mood (docstring style preference)
  "D205",    # blank-line-after-summary (docstring style preference)
  "PLR0912", # too-many-branches (complexity limit)
  "PLR0915", # too-many-statements (complexity limit)
  "S603",    # subprocess-without-shell-equals-true (sometimes needed)
  "TD002",   # missing-todo-author (not always needed)
  "TD003",   # missing-todo-link (not always needed)
]

# TODO/FIXME comment tags
task-tags = ["TODO", "FIXME", "XXX", "HACK"]

# Rules that cannot be auto-fixed
unfixable = ["B"]  # flake8-bugbear issues often need manual review

# Pylint-specific configuration
[tool.ruff.lint.pylint]
max-args = 8              # Maximum number of function arguments
max-locals = 15           # Maximum number of local variables
max-branches = 12         # Maximum number of branches in function
max-statements = 50       # Maximum number of statements in function

# Per-file rule ignores - customize for your project structure
[tool.ruff.lint.per-file-ignores]
"__init__.py" = ["E402"]                    # Allow imports not at top of file
"**/tests/**/*" = ["S101", "D100", "D103"] # Allow asserts, missing docstrings in tests
"scripts/**/*" = ["T201", "S602"]          # Allow print statements, shell calls in scripts

# MyPy configuration - static type checking
[tool.mypy]
python_version = "3.12"
strict = true                    # Enable all strict checks
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true
show_error_codes = true         # Show error codes in output
pretty = true                   # Use colored output

# Module-specific configurations
[[tool.mypy.overrides]]
module = ["tests.*"]
disallow_untyped_defs = false  # Allow untyped test functions

# Ruff formatter configuration (optional)
[tool.ruff.format]
quote-style = "double"           # Use double quotes for strings
indent-style = "space"           # Use spaces for indentation
skip-magic-trailing-comma = false
line-ending = "auto"             # Auto-detect line endings
docstring-code-format = true     # Format code blocks in docstrings
